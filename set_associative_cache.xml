<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE nta PUBLIC '-//Uppaal Team//DTD Flat System 1.1//EN' 'http://www.it.uu.se/research/group/darts/uppaal/flat-1_2.dtd'>
<nta>
	<declaration>/** Global declarations
 *
 * COPYRIGHT (c) 2018 Russell Maguire
 */

// Bus specification.
const int ADDR_WIDTH = 4;
const int ADDR_MAX = (1 &lt;&lt; ADDR_WIDTH) - 1;

const int LINE_WIDTH = 1;
const int TAG_WIDTH = ADDR_WIDTH - LINE_WIDTH;

const int LINE_OFFSET = 0;
const int TAG_OFFSET = LINE_OFFSET + LINE_WIDTH;
const int LINE_MAX = (1 &lt;&lt; LINE_WIDTH) - 1;

const bool READ = true;
const bool WRITE = false;</declaration>
	<template>
		<name x="5" y="5">Core</name>
		<parameter>bool &amp;addr[ADDR_WIDTH], bool &amp;readwrite, broadcast chan &amp;request, urgent chan &amp;response</parameter>
		<declaration>/** Core process template
 *
 * DESCRIPTION
 *    Template for process which generates randomly generates read and write requests
 *
 * INPUTS
 *    addr      - address bus array of boolean values
 *    readwrite - flag indicicating READ or WRITE
 *    request   - channel signaling memory request
 *    response  - channel signaling memory response
 *
 * COPYRIGHT (c) 2018 Russell Maguire
 */

clock t;</declaration>
		<location id="id0" x="-1036" y="-493">
			<name x="-1148" y="-501">ACCESS_END</name>
			<committed/>
		</location>
		<location id="id1" x="-756" y="-493">
			<name x="-740" y="-501">ACCESS_START</name>
			<committed/>
		</location>
		<location id="id2" x="-900" y="-493">
			<name x="-926" y="-476">WAITING</name>
		</location>
		<location id="id3" x="-1036" y="-357">
			<name x="-1084" y="-365">IDLE</name>
		</location>
		<init ref="id3"/>
		<transition>
			<source ref="id3"/>
			<target ref="id1"/>
			<label kind="select" x="-1020" y="-348">rand_addr0 : int[0,1],
rand_addr1 : int[0,1],
rand_addr2 : int[0,1],
rand_addr3 : int[0,1],
rand_readwrite : int[0,1]</label>
			<label kind="assignment" x="-833" y="-348">addr[0] = rand_addr0,
addr[1] = rand_addr1,
addr[2] = rand_addr2,
addr[3] = rand_addr3,
readwrite = rand_readwrite</label>
			<nail x="-756" y="-357"/>
		</transition>
		<transition>
			<source ref="id0"/>
			<target ref="id3"/>
		</transition>
		<transition>
			<source ref="id1"/>
			<target ref="id2"/>
			<label kind="synchronisation" x="-851" y="-520">request!</label>
			<label kind="assignment" x="-851" y="-494">t = 0</label>
		</transition>
		<transition>
			<source ref="id2"/>
			<target ref="id0"/>
			<label kind="synchronisation" x="-994" y="-519">response?</label>
		</transition>
	</template>
	<template>
		<name>Memory</name>
		<parameter>urgent chan &amp;request, chan &amp;response</parameter>
		<declaration>// MemController declarations
// COPYRIGHT (c) 2018 Russell Maguire

const int TMIN = 25;
const int TMAX = 30;

clock t;</declaration>
		<location id="id4" x="-25" y="-221">
			<name x="-9" y="-237">ACCESSING</name>
			<label kind="invariant" x="-9" y="-221">t &lt;= TMAX</label>
		</location>
		<location id="id5" x="-169" y="-77">
			<name x="-217" y="-85">IDLE</name>
		</location>
		<init ref="id5"/>
		<transition>
			<source ref="id5"/>
			<target ref="id4"/>
			<label kind="synchronisation" x="-17" y="-157">request?</label>
			<label kind="assignment" x="-17" y="-142">t = 0</label>
			<nail x="-25" y="-77"/>
		</transition>
		<transition>
			<source ref="id4"/>
			<target ref="id5"/>
			<label kind="guard" x="-156" y="-248">t &gt;= TMIN</label>
			<label kind="synchronisation" x="-156" y="-264">response!</label>
			<nail x="-169" y="-221"/>
		</transition>
	</template>
	<template>
		<name>Synchroniser</name>
		<parameter>urgent chan &amp;request, chan &amp;response, broadcast chan &amp;cache_request[2], chan &amp;cache_response[2]</parameter>
		<location id="id6" x="-42" y="0">
			<committed/>
		</location>
		<location id="id7" x="-212" y="0">
			<committed/>
		</location>
		<location id="id8" x="467" y="0">
			<name x="416" y="-8">END</name>
			<committed/>
		</location>
		<location id="id9" x="298" y="102">
		</location>
		<location id="id10" x="297" y="-93">
		</location>
		<location id="id11" x="119" y="0">
		</location>
		<location id="id12" x="-382" y="0">
			<name x="-392" y="-34">IDLE</name>
		</location>
		<init ref="id12"/>
		<transition>
			<source ref="id6"/>
			<target ref="id11"/>
			<label kind="synchronisation" x="-25" y="-17">cache_request[1]!</label>
		</transition>
		<transition>
			<source ref="id7"/>
			<target ref="id6"/>
			<label kind="synchronisation" x="-195" y="-17">cache_request[0]!</label>
		</transition>
		<transition>
			<source ref="id8"/>
			<target ref="id12"/>
			<label kind="synchronisation" x="485" y="-17">response!</label>
			<nail x="637" y="0"/>
			<nail x="637" y="153"/>
			<nail x="-382" y="153"/>
		</transition>
		<transition>
			<source ref="id9"/>
			<target ref="id8"/>
			<label kind="synchronisation" x="316" y="85">cache_response[0]?</label>
			<nail x="467" y="102"/>
		</transition>
		<transition>
			<source ref="id11"/>
			<target ref="id9"/>
			<label kind="synchronisation" x="137" y="85">cache_response[1]?</label>
			<nail x="119" y="102"/>
		</transition>
		<transition>
			<source ref="id10"/>
			<target ref="id8"/>
			<label kind="synchronisation" x="314" y="-110">cache_response[1]?</label>
			<nail x="467" y="-93"/>
		</transition>
		<transition>
			<source ref="id11"/>
			<target ref="id10"/>
			<label kind="synchronisation" x="137" y="-110">cache_response[0]?</label>
			<nail x="119" y="-93"/>
		</transition>
		<transition>
			<source ref="id12"/>
			<target ref="id7"/>
			<label kind="synchronisation" x="-305" y="-17">request?</label>
		</transition>
	</template>
	<template>
		<name>CacheLine</name>
		<parameter>const int id, const int num_sets, bool &amp;addr[ADDR_WIDTH], bool &amp;readwrite, urgent chan &amp;cache_request, chan &amp;cache_response, chan &amp;memory_request, urgent chan &amp;memory_response, broadcast chan &amp;cache_hit, broadcast chan &amp;cache_miss</parameter>
		<declaration>/**
 */

const int TMINR = 5;
const int TMAXR = 10;
const int TMINW = 25;
const int TMAXW = 30;

bool line[LINE_WIDTH];
bool tag[num_sets][TAG_WIDTH];
bool valid[num_sets];

// Local clock for timed cache accesses.
clock t;

void init_cache_line()
{
    for (i : int[0,LINE_WIDTH-1])
    {
        line[i] = (id &gt;&gt; (LINE_OFFSET+i)) &amp; 1;
    }
    for (i : int[0,num_sets-1])
    {
        valid[i] = false;
    }
}

/** Process-local check for cache line.
 */
bool is_cache_line()
{
    // Cache line if all line bits match.
    return forall (i : int[0,LINE_WIDTH-1]) addr[LINE_OFFSET+i] == line[i];
}

/** Process-local check for cache hit.
 */
bool is_cache_hit()
{
    // Cache hit if cache line is valid and all tag bits match.
    return exists (i : int[0,num_sets-1]) valid[i] and forall (j : int[0,TAG_WIDTH-1]) addr[TAG_OFFSET+j] == tag[i][j];
}

/** Process-local procedure to update cache tag and valid bits.
 */
void update_cache_line(const int set)
{
    // Only model tag, don't bother writing data.
    for (i : int[0,TAG_WIDTH-1])
    {
        tag[set][i] = addr[TAG_OFFSET+i];
    }

    // Set cache valid bit.
    valid[set] = true;
}</declaration>
		<location id="id13" x="-380" y="-105">
			<name x="-388" y="-137">START</name>
			<committed/>
		</location>
		<location id="id14" x="-84" y="-105">
			<name x="-76" y="-129">READY</name>
			<committed/>
		</location>
		<location id="id15" x="228" y="-105">
			<name x="236" y="-129">WRITE_START</name>
			<committed/>
		</location>
		<location id="id16" x="740" y="-105">
			<name x="756" y="-113">ACCESS_END</name>
			<committed/>
		</location>
		<location id="id17" x="564" y="-33">
			<name x="556" y="-81">WRITING_CACHE</name>
			<label kind="invariant" x="556" y="-65">t &lt;= TMAXW</label>
		</location>
		<location id="id18" x="564" y="-177">
			<name x="556" y="-161">WRITING_MEMORY</name>
		</location>
		<location id="id19" x="396" y="-249">
			<name x="388" y="-297">READING_CACHE</name>
			<label kind="invariant" x="388" y="-281">t &lt;= TMAXR</label>
		</location>
		<location id="id20" x="396" y="39">
			<name x="388" y="55">READING_MEMORY</name>
		</location>
		<location id="id21" x="396" y="-105">
			<name x="412" y="-121">WRITING</name>
			<label kind="invariant" x="412" y="-105">t &lt;= TMAXW</label>
		</location>
		<location id="id22" x="228" y="-249">
			<name x="220" y="-281">HIT_START</name>
			<committed/>
		</location>
		<location id="id23" x="228" y="39">
			<name x="220" y="55">MISS_START</name>
			<committed/>
		</location>
		<location id="id24" x="68" y="-105">
			<name x="84" y="-113">ACCESS_START</name>
			<committed/>
		</location>
		<location id="id25" x="-228" y="-105">
			<name x="-220" y="-129">IDLE</name>
		</location>
		<init ref="id13"/>
		<transition>
			<source ref="id13"/>
			<target ref="id25"/>
			<label kind="assignment" x="-364" y="-97">init_cache_line()</label>
		</transition>
		<transition>
			<source ref="id14"/>
			<target ref="id25"/>
			<label kind="guard" x="-220" y="-201">!is_cache_line()</label>
			<nail x="-84" y="-177"/>
			<nail x="-228" y="-177"/>
		</transition>
		<transition>
			<source ref="id14"/>
			<target ref="id24"/>
			<label kind="guard" x="-68" y="-97">is_cache_line()</label>
			<label kind="assignment" x="-68" y="-81">t = 0</label>
		</transition>
		<transition>
			<source ref="id15"/>
			<target ref="id21"/>
			<label kind="synchronisation" x="244" y="-97">memory_request!</label>
		</transition>
		<transition>
			<source ref="id23"/>
			<target ref="id15"/>
			<label kind="guard" x="236" y="-41">readwrite == WRITE</label>
		</transition>
		<transition>
			<source ref="id22"/>
			<target ref="id15"/>
			<label kind="guard" x="236" y="-185">readwrite == WRITE</label>
		</transition>
		<transition>
			<source ref="id19"/>
			<target ref="id16"/>
			<label kind="guard" x="524" y="-273">t &gt;= TMINR</label>
			<nail x="740" y="-249"/>
		</transition>
		<transition>
			<source ref="id16"/>
			<target ref="id25"/>
			<label kind="select" x="748" y="-33">rand_set : int[0,num_sets-1]</label>
			<label kind="synchronisation" x="748" y="-17">cache_response!</label>
			<label kind="assignment" x="748" y="-1">update_cache_line(rand_set)</label>
			<nail x="740" y="111"/>
			<nail x="-228" y="111"/>
		</transition>
		<transition>
			<source ref="id20"/>
			<target ref="id17"/>
			<label kind="synchronisation" x="412" y="-1">memory_response?</label>
			<label kind="assignment" x="412" y="15">t = 0</label>
			<nail x="564" y="39"/>
		</transition>
		<transition>
			<source ref="id17"/>
			<target ref="id16"/>
			<label kind="guard" x="588" y="-25">t &gt;= TMINW</label>
			<nail x="676" y="-33"/>
		</transition>
		<transition>
			<source ref="id18"/>
			<target ref="id16"/>
			<label kind="synchronisation" x="580" y="-201">memory_response?</label>
			<nail x="676" y="-177"/>
		</transition>
		<transition>
			<source ref="id21"/>
			<target ref="id17"/>
			<label kind="synchronisation" x="412" y="-57">memory_response?</label>
			<nail x="396" y="-33"/>
		</transition>
		<transition>
			<source ref="id21"/>
			<target ref="id18"/>
			<label kind="guard" x="412" y="-201">t &gt;= TMINW</label>
			<nail x="396" y="-177"/>
		</transition>
		<transition>
			<source ref="id22"/>
			<target ref="id19"/>
			<label kind="guard" x="244" y="-241">readwrite == READ</label>
		</transition>
		<transition>
			<source ref="id23"/>
			<target ref="id20"/>
			<label kind="guard" x="244" y="-1">readwrite == READ</label>
			<label kind="synchronisation" x="244" y="15">memory_request!</label>
		</transition>
		<transition>
			<source ref="id24"/>
			<target ref="id23"/>
			<label kind="guard" x="84" y="-1">!is_cache_hit()</label>
			<label kind="synchronisation" x="84" y="15">cache_miss!</label>
			<nail x="68" y="39"/>
		</transition>
		<transition>
			<source ref="id24"/>
			<target ref="id22"/>
			<label kind="guard" x="84" y="-289">is_cache_hit()</label>
			<label kind="synchronisation" x="84" y="-273">cache_hit!</label>
			<nail x="68" y="-249"/>
		</transition>
		<transition>
			<source ref="id25"/>
			<target ref="id14"/>
			<label kind="synchronisation" x="-212" y="-97">cache_request?</label>
		</transition>
	</template>
	<template>
		<name>CacheCounter</name>
		<parameter>urgent chan &amp;cache_hit, urgent chan &amp;cache_miss</parameter>
		<declaration>/**
 */

int cache_hits = 0;
int cache_misses = 0;

/** Greater than or equal to
 */
bool hit_rate_ge(const int hit_rate)
{
    return cache_hits + cache_misses &gt; 0
        &amp;&amp; (100 - hit_rate) * cache_hits &gt;= hit_rate * cache_misses;
}</declaration>
		<location id="id26" x="-266" y="-152">
			<name x="-250" y="-160">IDLE</name>
		</location>
		<init ref="id26"/>
		<transition>
			<source ref="id26"/>
			<target ref="id26"/>
			<label kind="synchronisation" x="-314" y="-64">cache_miss?</label>
			<label kind="assignment" x="-314" y="-48">cache_misses++</label>
			<nail x="-194" y="-72"/>
			<nail x="-338" y="-72"/>
		</transition>
		<transition>
			<source ref="id26"/>
			<target ref="id26"/>
			<label kind="synchronisation" x="-314" y="-272">cache_hit?</label>
			<label kind="assignment" x="-314" y="-256">cache_hits++</label>
			<nail x="-194" y="-232"/>
			<nail x="-338" y="-232"/>
		</transition>
	</template>
	<system>/** Main memory system
 * COPYRIGHT (c) 2018 Russell Maguire
 */

// Address bus.
bool addr[ADDR_WIDTH];
bool readwrite;

// Channels
chan request;
chan response;

broadcast chan cache_request[2];
chan cache_response[2];

chan memory_request[2];
chan memory_response[2];

broadcast chan cache_hit[2];
broadcast chan cache_miss[2];

// System processes
core = Core(addr, readwrite, request, response);
synchroniser = Synchroniser(
    request,
    response,
    cache_request,
    cache_response
);

// Two caches, one is direct mapped, the other is set associative
cache_line(const int[1,2] num_sets, const int[0,LINE_MAX] id) = CacheLine(
    id,
    num_sets,
    addr,
    readwrite,
    cache_request[num_sets-1],
    cache_response[num_sets-1],
    memory_request[num_sets-1],
    memory_response[num_sets-1],
    cache_hit[num_sets-1],
    cache_miss[num_sets-1]
);
memory(const int[1,2] num_sets) = Memory(
    memory_request[num_sets-1],
    memory_response[num_sets-1]
);
cache_counter(const int[1,2] num_sets) = CacheCounter(
    cache_hit[num_sets-1],
    cache_miss[num_sets-1]
);

// Direct mapped cache with one set, set associative cache with two sets.
// Cannot leave this as a free process parameter due to select statement
// with dependency on number of sets.
dm_cache_line(const int[0,LINE_MAX] id) = cache_line(1, id);
sa_cache_line(const int[0,LINE_MAX] id) = cache_line(2, id);

system core, synchroniser, dm_cache_line, sa_cache_line, memory, cache_counter;</system>
	<queries>
		<query>
			<formula>E&lt;&gt;synchroniser.END and (cache_counter(2).cache_hits &gt; cache_counter(1).cache_hits)
			</formula>
			<comment>
			</comment>
		</query>
		<query>
			<formula>core.ACCESS_START --&gt; core.ACCESS_END
			</formula>
			<comment>
			</comment>
		</query>
	</queries>
</nta>
