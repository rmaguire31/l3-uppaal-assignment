<?xml version="1.0" encoding="utf-8"?><!DOCTYPE nta PUBLIC '-//Uppaal Team//DTD Flat System 1.1//EN' 'http://www.it.uu.se/research/group/darts/uppaal/flat-1_1.dtd'><nta><declaration>/** Global declarations
 *
 * COPYRIGHT (c) 2018 Russell Maguire
 */

// Constants.
const int ADDR_WIDTH = 4;
const int ADDR_MAX = (1 &lt;&lt; ADDR_WIDTH) - 1;

const bool READ = true;
const bool WRITE = false;

// Global clock.
clock time;</declaration><template><name x="5" y="5">Core</name><parameter>bool &amp;addr[ADDR_WIDTH], bool &amp;readwrite, broadcast chan &amp;request, urgent chan &amp;response</parameter><declaration>/** Core process template
 *
 * DESCRIPTION
 *    Template for process which generates randomly generates read and write requests
 *
 * INPUTS
 *    addr     - address bus array of boolean values
 *    rw       - flag indicicating RW_WRITE or RW_READ
 *    request  - channel signaling memory request
 *    response - channel signaling memory response
 *
 * COPYRIGHT (c) 2018 Russell Maguire
 */

clock t;

void update_addr(const int[0,ADDR_MAX] value)
{
    int i;
    for (i : int[0,ADDR_WIDTH-1])
    {
        addr[i] = (value &gt;&gt; i) &amp; 1;
    }
}

void update_readwrite(const bool value)
{
    readwrite = value;
}</declaration><location id="id0" x="-992" y="-160"><name x="-1104" y="-168">ACCESS_END</name><committed/></location><location id="id1" x="-712" y="-160"><name x="-696" y="-168">ACCESS_START</name><committed/></location><location id="id2" x="-856" y="-160"><name x="-882" y="-143">WAITING</name></location><location id="id3" x="-992" y="-24"><name x="-1040" y="-32">IDLE</name></location><init ref="id3"/><transition><source ref="id3"/><target ref="id1"/><label kind="select" x="-968" y="-56">rand0 : int[0,ADDR_MAX],
rand1 : int[0,1]</label><label kind="assignment" x="-968" y="-24">update_addr(rand0),
update_readwrite(rand1)</label><nail x="-712" y="-24"/></transition><transition><source ref="id0"/><target ref="id3"/></transition><transition><source ref="id1"/><target ref="id2"/><label kind="synchronisation" x="-807" y="-187">request!</label><label kind="assignment" x="-807" y="-161">t = 0</label></transition><transition><source ref="id2"/><target ref="id0"/><label kind="synchronisation" x="-950" y="-186">response?</label></transition></template><template><name>Memory</name><parameter>urgent chan &amp;request, chan &amp;response</parameter><declaration>// MemController declarations
// COPYRIGHT (c) 2018 Russell Maguire

const int TMIN = 25;
const int TMAX = 30;

clock t;</declaration><location id="id4" x="72" y="-144"><name x="88" y="-160">ACCESSING</name><label kind="invariant" x="88" y="-144">t &lt;= TMAX</label></location><location id="id5" x="-72" y="0"><name x="-120" y="-8">IDLE</name></location><init ref="id5"/><transition><source ref="id5"/><target ref="id4"/><label kind="synchronisation" x="80" y="-80">request?</label><label kind="assignment" x="80" y="-65">t = 0</label><nail x="72" y="0"/></transition><transition><source ref="id4"/><target ref="id5"/><label kind="guard" x="-59" y="-171">t &gt;= TMIN</label><label kind="synchronisation" x="-59" y="-187">response!</label><nail x="-72" y="-144"/></transition></template><system>/** Main memory system
 * COPYRIGHT (c) 2018 Russell Maguire
 */

// Address bus.
bool addr[ADDR_WIDTH];
bool readwrite;

// Channels
broadcast chan request;
chan response;

// System processes
// core.read and core.write both use the same generic memory access channel
core = Core(addr, readwrite, request, response);
memory = Memory(request, response);

system core, memory;</system></nta>